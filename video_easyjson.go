// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package innertube

import (
	json "encoding/json"
	fmt "fmt"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
	time "time"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson3c9ce8c3DecodeGithubComAntoniszymanskiInnertubeGo(in *jlexer.Lexer, out *rawVideo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	var VideoDetailsSet bool
	var MicroformatSet bool
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "videoDetails":
			easyjson3c9ce8c3Decode(in, &out.VideoDetails)
			VideoDetailsSet = true
		case "microformat":
			easyjson3c9ce8c3Decode1(in, &out.Microformat)
			MicroformatSet = true
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
	if !VideoDetailsSet {
		in.AddError(fmt.Errorf("key 'videoDetails' is required"))
	}
	if !MicroformatSet {
		in.AddError(fmt.Errorf("key 'microformat' is required"))
	}
}
func easyjson3c9ce8c3EncodeGithubComAntoniszymanskiInnertubeGo(out *jwriter.Writer, in rawVideo) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"videoDetails\":"
		out.RawString(prefix[1:])
		easyjson3c9ce8c3Encode(out, in.VideoDetails)
	}
	{
		const prefix string = ",\"microformat\":"
		out.RawString(prefix)
		easyjson3c9ce8c3Encode1(out, in.Microformat)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v rawVideo) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson3c9ce8c3EncodeGithubComAntoniszymanskiInnertubeGo(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v rawVideo) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson3c9ce8c3EncodeGithubComAntoniszymanskiInnertubeGo(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *rawVideo) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson3c9ce8c3DecodeGithubComAntoniszymanskiInnertubeGo(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *rawVideo) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson3c9ce8c3DecodeGithubComAntoniszymanskiInnertubeGo(l, v)
}
func easyjson3c9ce8c3Decode1(in *jlexer.Lexer, out *struct {
	PlayerMicroformatRenderer struct {
		PublishDate time.Time `json:"publishDate,required"`
		LikeCount   string    `json:"likeCount,required"`
	} `json:"playerMicroformatRenderer,required"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	var PlayerMicroformatRendererSet bool
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "playerMicroformatRenderer":
			easyjson3c9ce8c3Decode2(in, &out.PlayerMicroformatRenderer)
			PlayerMicroformatRendererSet = true
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
	if !PlayerMicroformatRendererSet {
		in.AddError(fmt.Errorf("key 'playerMicroformatRenderer' is required"))
	}
}
func easyjson3c9ce8c3Encode1(out *jwriter.Writer, in struct {
	PlayerMicroformatRenderer struct {
		PublishDate time.Time `json:"publishDate,required"`
		LikeCount   string    `json:"likeCount,required"`
	} `json:"playerMicroformatRenderer,required"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"playerMicroformatRenderer\":"
		out.RawString(prefix[1:])
		easyjson3c9ce8c3Encode2(out, in.PlayerMicroformatRenderer)
	}
	out.RawByte('}')
}
func easyjson3c9ce8c3Decode2(in *jlexer.Lexer, out *struct {
	PublishDate time.Time `json:"publishDate,required"`
	LikeCount   string    `json:"likeCount,required"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	var PublishDateSet bool
	var LikeCountSet bool
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "publishDate":
			if data := in.Raw(); in.Ok() {
				in.AddError((out.PublishDate).UnmarshalJSON(data))
			}
			PublishDateSet = true
		case "likeCount":
			out.LikeCount = string(in.String())
			LikeCountSet = true
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
	if !PublishDateSet {
		in.AddError(fmt.Errorf("key 'publishDate' is required"))
	}
	if !LikeCountSet {
		in.AddError(fmt.Errorf("key 'likeCount' is required"))
	}
}
func easyjson3c9ce8c3Encode2(out *jwriter.Writer, in struct {
	PublishDate time.Time `json:"publishDate,required"`
	LikeCount   string    `json:"likeCount,required"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"publishDate\":"
		out.RawString(prefix[1:])
		out.Raw((in.PublishDate).MarshalJSON())
	}
	{
		const prefix string = ",\"likeCount\":"
		out.RawString(prefix)
		out.String(string(in.LikeCount))
	}
	out.RawByte('}')
}
func easyjson3c9ce8c3Decode(in *jlexer.Lexer, out *struct {
	VideoID          string `json:"videoId,required"`
	Title            string `json:"title,required"`
	LengthSeconds    string `json:"lengthSeconds,required"`
	ChannelID        string `json:"channelId,required"`
	ShortDescription string `json:"shortDescription,required"`
	Thumbnail        struct {
		Thumbnails []Thumbnail `json:"thumbnails,required"`
	} `json:"thumbnail,required"`
	ViewCount     string `json:"viewCount,required"`
	Author        string `json:"author,required"`
	IsPrivate     bool   `json:"isPrivate,required"`
	IsLiveContent bool   `json:"isLiveContent,required"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	var VideoIDSet bool
	var TitleSet bool
	var LengthSecondsSet bool
	var ChannelIDSet bool
	var ShortDescriptionSet bool
	var ThumbnailSet bool
	var ViewCountSet bool
	var AuthorSet bool
	var IsPrivateSet bool
	var IsLiveContentSet bool
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "videoId":
			out.VideoID = string(in.String())
			VideoIDSet = true
		case "title":
			out.Title = string(in.String())
			TitleSet = true
		case "lengthSeconds":
			out.LengthSeconds = string(in.String())
			LengthSecondsSet = true
		case "channelId":
			out.ChannelID = string(in.String())
			ChannelIDSet = true
		case "shortDescription":
			out.ShortDescription = string(in.String())
			ShortDescriptionSet = true
		case "thumbnail":
			easyjson3c9ce8c3Decode3(in, &out.Thumbnail)
			ThumbnailSet = true
		case "viewCount":
			out.ViewCount = string(in.String())
			ViewCountSet = true
		case "author":
			out.Author = string(in.String())
			AuthorSet = true
		case "isPrivate":
			out.IsPrivate = bool(in.Bool())
			IsPrivateSet = true
		case "isLiveContent":
			out.IsLiveContent = bool(in.Bool())
			IsLiveContentSet = true
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
	if !VideoIDSet {
		in.AddError(fmt.Errorf("key 'videoId' is required"))
	}
	if !TitleSet {
		in.AddError(fmt.Errorf("key 'title' is required"))
	}
	if !LengthSecondsSet {
		in.AddError(fmt.Errorf("key 'lengthSeconds' is required"))
	}
	if !ChannelIDSet {
		in.AddError(fmt.Errorf("key 'channelId' is required"))
	}
	if !ShortDescriptionSet {
		in.AddError(fmt.Errorf("key 'shortDescription' is required"))
	}
	if !ThumbnailSet {
		in.AddError(fmt.Errorf("key 'thumbnail' is required"))
	}
	if !ViewCountSet {
		in.AddError(fmt.Errorf("key 'viewCount' is required"))
	}
	if !AuthorSet {
		in.AddError(fmt.Errorf("key 'author' is required"))
	}
	if !IsPrivateSet {
		in.AddError(fmt.Errorf("key 'isPrivate' is required"))
	}
	if !IsLiveContentSet {
		in.AddError(fmt.Errorf("key 'isLiveContent' is required"))
	}
}
func easyjson3c9ce8c3Encode(out *jwriter.Writer, in struct {
	VideoID          string `json:"videoId,required"`
	Title            string `json:"title,required"`
	LengthSeconds    string `json:"lengthSeconds,required"`
	ChannelID        string `json:"channelId,required"`
	ShortDescription string `json:"shortDescription,required"`
	Thumbnail        struct {
		Thumbnails []Thumbnail `json:"thumbnails,required"`
	} `json:"thumbnail,required"`
	ViewCount     string `json:"viewCount,required"`
	Author        string `json:"author,required"`
	IsPrivate     bool   `json:"isPrivate,required"`
	IsLiveContent bool   `json:"isLiveContent,required"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"videoId\":"
		out.RawString(prefix[1:])
		out.String(string(in.VideoID))
	}
	{
		const prefix string = ",\"title\":"
		out.RawString(prefix)
		out.String(string(in.Title))
	}
	{
		const prefix string = ",\"lengthSeconds\":"
		out.RawString(prefix)
		out.String(string(in.LengthSeconds))
	}
	{
		const prefix string = ",\"channelId\":"
		out.RawString(prefix)
		out.String(string(in.ChannelID))
	}
	{
		const prefix string = ",\"shortDescription\":"
		out.RawString(prefix)
		out.String(string(in.ShortDescription))
	}
	{
		const prefix string = ",\"thumbnail\":"
		out.RawString(prefix)
		easyjson3c9ce8c3Encode3(out, in.Thumbnail)
	}
	{
		const prefix string = ",\"viewCount\":"
		out.RawString(prefix)
		out.String(string(in.ViewCount))
	}
	{
		const prefix string = ",\"author\":"
		out.RawString(prefix)
		out.String(string(in.Author))
	}
	{
		const prefix string = ",\"isPrivate\":"
		out.RawString(prefix)
		out.Bool(bool(in.IsPrivate))
	}
	{
		const prefix string = ",\"isLiveContent\":"
		out.RawString(prefix)
		out.Bool(bool(in.IsLiveContent))
	}
	out.RawByte('}')
}
func easyjson3c9ce8c3Decode3(in *jlexer.Lexer, out *struct {
	Thumbnails []Thumbnail `json:"thumbnails,required"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	var ThumbnailsSet bool
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "thumbnails":
			if in.IsNull() {
				in.Skip()
				out.Thumbnails = nil
			} else {
				in.Delim('[')
				if out.Thumbnails == nil {
					if !in.IsDelim(']') {
						out.Thumbnails = make([]Thumbnail, 0, 2)
					} else {
						out.Thumbnails = []Thumbnail{}
					}
				} else {
					out.Thumbnails = (out.Thumbnails)[:0]
				}
				for !in.IsDelim(']') {
					var v1 Thumbnail
					easyjson3c9ce8c3DecodeGithubComAntoniszymanskiInnertubeGo1(in, &v1)
					out.Thumbnails = append(out.Thumbnails, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
			ThumbnailsSet = true
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
	if !ThumbnailsSet {
		in.AddError(fmt.Errorf("key 'thumbnails' is required"))
	}
}
func easyjson3c9ce8c3Encode3(out *jwriter.Writer, in struct {
	Thumbnails []Thumbnail `json:"thumbnails,required"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"thumbnails\":"
		out.RawString(prefix[1:])
		if in.Thumbnails == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Thumbnails {
				if v2 > 0 {
					out.RawByte(',')
				}
				easyjson3c9ce8c3EncodeGithubComAntoniszymanskiInnertubeGo1(out, v3)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson3c9ce8c3DecodeGithubComAntoniszymanskiInnertubeGo1(in *jlexer.Lexer, out *Thumbnail) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	var URLSet bool
	var WidthSet bool
	var HeightSet bool
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "url":
			out.URL = string(in.String())
			URLSet = true
		case "width":
			out.Width = int(in.Int())
			WidthSet = true
		case "height":
			out.Height = int(in.Int())
			HeightSet = true
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
	if !URLSet {
		in.AddError(fmt.Errorf("key 'url' is required"))
	}
	if !WidthSet {
		in.AddError(fmt.Errorf("key 'width' is required"))
	}
	if !HeightSet {
		in.AddError(fmt.Errorf("key 'height' is required"))
	}
}
func easyjson3c9ce8c3EncodeGithubComAntoniszymanskiInnertubeGo1(out *jwriter.Writer, in Thumbnail) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"url\":"
		out.RawString(prefix[1:])
		out.String(string(in.URL))
	}
	{
		const prefix string = ",\"width\":"
		out.RawString(prefix)
		out.Int(int(in.Width))
	}
	{
		const prefix string = ",\"height\":"
		out.RawString(prefix)
		out.Int(int(in.Height))
	}
	out.RawByte('}')
}
